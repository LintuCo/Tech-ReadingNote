# 应用层

## DNS

为了将一个名字映射成IP地址，程序调用解析器，将名字作为参数传递给此程序。本地DNS服务器查询该名字，返回一个包含IP地址的响应报文给解析器。查询报文和响应报文通过UDP数据包发送。

## Cookie & Session

由于HTTP协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识具体的用户，这个机制就是Session.

用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，

- Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；
- Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式

## HTTP-超文本传输协议

### HTTP1.0

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。

### HTTP1.1

首先是长连接，HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求。

HTTP1.1支持请求管道化（pipelining）。基于HTTP1.1的长连接，使得请求管线化成为可能。管线化使得请求能够“并行”传输。**服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容** 

HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）

## GET和POST

**GET**
1. GET 请求可以被缓存
2. GET 请求保留在浏览器历史记录中
3. GET 请求可被收藏为书签
4. GET 请求不应在处理敏感数据时使用（即通常所说的数据不加密）
5. GET 请求有长度限制
6. GET 请求只应当用于从服务器取回数据

**POST**
1. POST 请求不会被缓存
2. POST 请求不会保留在浏览器历史记录中
3. POST 请求不能被收藏为书签
4. POST 请求对数据长度没有要求
5. POST 请求可以用于处理敏感数据

![POST-GET](http://p82ueiq23.bkt.clouddn.com/POST-GET.png)

## HTTPS原理

[HTTPS](https://segmentfault.com/a/1190000014042724)

**https通信过程**
1. 浏览器发起往服务器的 443 端口发起请求，请求携带了浏览器支持的加密算法和哈希算法。
2. 服务器收到请求，选择浏览器支持的加密算法和哈希算法。
3. 服务器下将数字证书返回给浏览器，这里的数字证书可以是向某个可靠机构申请的，也可以是自制的。
4. 浏览器进入数字证书认证环节，这一部分是浏览器内置的 TSL 完成的：

首先浏览器会从内置的证书列表中索引，找到服务器下发证书对应的机构，如果没有找到，此时就会提示用户该证书是不是由权威机构颁发，是不可信任的。如果查到了对应的机构，则取出该机构颁发的公钥。
用机构的证书公钥解密得到证书的内容和证书签名，内容包括网站的网址、网站的公钥、证书的有效期等。浏览器会先验证证书签名的合法性。签名通过后（用机构的公钥解密证书签名得到的哈希值和证书内容的哈希值匹配），浏览器验证证书记录的网址是否和当前网址是一致的，不一致会提示用户。如果网址一致会检查证书有效期，证书过期了也会提示用户。这些都通过认证时，浏览器就可以安全使用证书中的网站公钥了。
浏览器生成一个随机数 R，并使用网站公钥对 R 进行加密。
浏览器将加密的 R 传送给服务器。
服务器用自己的私钥解密得到 R。
服务器以 R 为密钥使用了对称加密算法加密网页内容并传输给浏览器。
浏览器以 R 为密钥使用之前约定好的解密算法获取网页内容。

## 总结

**HTTP1.0**
- 无状态、无连接

**HTTP1.1**
- 持久连接
- 请求管道化
- 增加缓存处理（新的字段如cache-control）
- 增加Host字段、支持断点传输等

**HTTP2.0**
- 二进制分帧
- 多路复用（或连接共享）
- 头部压缩
- 服务器推送

## HTTP header

![http-header](http://p82ueiq23.bkt.clouddn.com/http-header.PNG)

## HTTP常见状态码

200，301，302，404，500

**1XX**：临时响应并需要请求者继续执行操作的状态代码
- 100 (继续) 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
- 101 (切换协议) 请求者已要求服务器切换协议，服务器已确认并准备切换。

**2xx**： (成功)表示成功处理了请求的状态代码
- **200** (成功) 服务器已成功处理了请求。
- 201 (已创建) 请求成功并且服务器创建了新的资源。
- 202 (已接受) 服务器已接受请求，但尚未处理。
- 203 (非授权信息) 服务器已成功处理了请求，但返回的信息可能来自另一来源。
- 204 (无内容) 服务器成功处理了请求，但没有返回任何内容。
- 205 (重置内容) 服务器成功处理了请求，但没有返回任何内容。
- 206 (部分内容) 服务器成功处理了部分 GET 请求。

**3xx**： (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
- 300 (多种选择) 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
- **301** (永久移动) 请求的网页已永久移动到新位置。 服务器返回此响应(对 GET 或 HEAD 请求的响应)时，会自动将请求者转到新位置。
- 302 (临时移动) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
- 303 (查看其他位置) 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
- 304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
- 305 (使用代理) 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
- 307 (临时重定向) 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

**4xx**：(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理。
- 400 (错误请求) 服务器不理解请求的语法。
- 401 (未授权) 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
- 403 (禁止) 服务器拒绝请求。
- 404 (未找到) 服务器找不到请求的网页。
- 405 (方法禁用) 禁用请求中指定的方法。
- 406 (不接受) 无法使用请求的内容特性响应请求的网页。
- 407 (需要代理授权) 此状态代码与 401(未授权)类似，但指定请求者应当授权使用代理。
- 408 (请求超时) 服务器等候请求时发生超时。
- 409 (冲突) 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
- 410 (已删除) 如果请求的资源已永久删除，服务器就会返回此响应。
- 411 (需要有效长度) 服务器不接受不含有效内容长度标头字段的请求。
- 412 (未满足前提条件) 服务器未满足请求者在请求中设置的其中一个前提条件。
- 413 (请求实体过大) 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
- 414 (请求的 URI 过长) 请求的 URI(通常为网址)过长，服务器无法处理。
- 415 (不支持的媒体类型) 请求的格式不受请求页面的支持。
- 416 (请求范围不符合要求) 如果页面无法提供请求的范围，则服务器会返回此状态代码。
- 417 (未满足期望值) 服务器未满足"期望"请求标头字段的要求。

**5xx**：(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。
- 500 (服务器内部错误) 服务器遇到错误，无法完成请求。
- 501 (尚未实施) 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
- 502 (错误网关) 服务器作为网关或代理，从上游服务器收到无效响应。
- 503 (服务不可用) 服务器目前无法使用(由于超载或停机维护)。 通常，这只是暂时状态。
- 504 (网关超时) 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
- 505 (HTTP 版本不受支持) 服务器不支持请求中所用的 HTTP 协议版本。