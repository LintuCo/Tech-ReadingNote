
## 前言

Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。
键的类型只能为字符串，值支持的五种类型数据类型为：字符串、列表、集合、有序集合、散列表。
Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能

## 数据类型

| 数据类型 |      可以存储的值      |                                                       操作                                                       |
|:--------:|:----------------------:|:------------------------------------------------------------------------------------------------------:|
|  STRING  | 字符串、整数或者浮点数 |                对整个字符串或者字符串的其中一部分执行操作</br> 对整数和浮点数执行自增或者自减操作                |
|   LIST   |          列表          |              从两端压入或者弹出元素</br> 读取单个或者多个元素</br> 进行修剪，只保留一个范围内的元素              |
|   SET    |        无序集合        | 添加、获取、移除单个元素</br> 检查一个元素是否存在于集合中</br> 计算交集、并集、差集</br> 从集合里面随机获取元素 |
|   HASH   | 包含键值对的无序散列表 |                      添加、获取、移除单个键值对</br> 获取所有键值对</br> 检查某个键是否存在                      |
|   ZSET   |        有序集合        |                  添加、获取、删除元素</br> 根据分值范围或者成员来获取元素</br> 计算一个键的排名                  |

## 数据结构

### 字典

dictht 是一个散列表结构，使用拉链法保存哈希冲突的 dictEntry。

```java
/* This is our hash table structure. Every dictionary has two of this as we
 * implement incremental rehashing, for the old to the new table. */
typedef struct dictht {
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
```

### 跳跃表

是有序集合的底层实现之一。
跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。

![跳跃表](http://p82ueiq23.bkt.clouddn.com/%E8%B7%B3%E8%B7%83%E8%A1%A8.png)


### 发布与订阅



## 使用场景

### 技术器

- 可以对 String 进行自增自减运算，从而实现计数器功能。
- Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

### 缓存

- 将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

### 查找表

- DNS 记录就很适合使用 Redis 进行存储。

### 消息队列

- List 是一个双向链表，可以通过 lpop 和 lpush 写入和读取消息。

### 会话缓存

- 在分布式场景下具有多个应用服务器，可以使用 Redis 来统一存储这些应用服务器的会话信息。
- 当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器。

### 分布式锁

- 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。
- 可以使用 Reids 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。
- 先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放，

## Redis与Memcached的区别

**数据类型**
- Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。

**数据持久化**
- Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。

**分布式**
- Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。

**内存管理机制**
- 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中
- Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题，但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。

## 持久化

### RDB持久化
- 将某个时间点的所有数据都存放到硬盘上。
- 可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。
- 如果系统发生故障，将会丢失最后一次创建快照之后的数据。
- 如果数据量很大，保存快照的时间会很长。

### AOF持久化

将写命令添加到 AOF 文件（Append Only File）的末尾。

## 复制

- 通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。
- 一个从服务器只能有一个主服务器，并且不支持主主复制。

### 连接过程

- 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；
- 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；
- 主服务器每执行一次写命令，就向从服务器发送相同的写命令。

## Sentinel

- Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

## 分片

- 分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，也可以从多台机器里面获取数据，这种方法在解决某些问题时可以获得线性级别的性能提升。

根据执行分片的位置，可以分为三种分片方式：
- 客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。
- 代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。
- 服务器分片：Redis Cluster。

## Problem List

#### 1. 假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

- 使用keys指令可以扫出指定模式的key列表（keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复）。
- 使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

#### 2. Redis做异步队列

- list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
- blpop，在没有消息的时候，它会阻塞住直到消息到来。
- 使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
- 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

#### 3. Pipeline有什么好处，为什么要用pipeline？

可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

#### 4. Redis的同步机制了解么？

Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。