# 对象的共享

## 可见性

### 失效数据

### 非原子位的64为操作

### 加锁与可见性

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

### `Volatile`变量

volatile变量用来确保将变量的更新通知通知到其他线程。当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是共享的，不会将该变量上的操作与其他内存操作一起重排序。`volatile`类型不会被缓存在寄存器或者其他对处理器不可见的地方

**volatile与synchronized的区别**：加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。

## 发布和逃逸

**发布** 使对象能够在当前作用域之外的代码中使用，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某个非私有的方法中返回该引用，或者将引用传递到其他类的方法中。

**逃逸** 当某个不应该发布的对象被发布

## 线程封闭

**线程封闭(Thread Confinement)** 不共享数据

### `Ad-hoc`线程封闭

**线程封闭** 维护线程封闭性的职责完全由程序来承担
**缺点** 在使用线程封闭技术时，通常要将某个特定的子系统实现为一个单线程系统，而某些情况下，单线程子系统提供的简便性胜过`ad-hoc`线程封闭技术的脆弱性。

### 栈封闭

**栈封闭** 只能通过局部变量访问对象，但是需要确保对象不会逃逸

### `ThreadLocal`类

**ThreadLocal** 使线程中的某个值与保存值的对象关联起来，提供`get()`和` set()`方法为每个使用该变量的线程都存有一份独立的副本。
**作用** 防止对可变的单实例变量或者全局变量进行共享。