

### 隔离级别

#### 未提交读

事务中的修改，即使没有提交，对其他事务都是可见的。事务可以读取未提交的数据（脏读）

#### 提交读

一个事务从开始直到提交之前，所做的任何修改对其他事务都不可见（不可重复读）

#### 可重复读

保证了在同一个事务中多次读取同样记录的结果是一致的。但是可能存在幻读，**当某个事务在读取某个范围内的记录时，另外一个事务在该范围内插入了新的记录，当之前的事务再次读取该范围内的记录时，产生幻行**。

#### 可串行化

强制事务串行执行，在读取每一行数据上加锁

#### 问题

**脏读**：脏读是指在一个事务处理过程里读取到了另一个未提交的事务中的数据。*例如，事务T1修改某一数据并将其写回磁盘，事务T2读取同一数据后，T1由于某种原因被撤销，此时被T1修改过的数据恢复原值，T2读到的数据就与数据库中的数据不一致，则T2读到的数据就为“脏数据”，即不正确的数据。(修改时允许读取导致脏读)*
**不可重复读**：不可重复读是指在同一个事务内，针对同一数据进行多次相同的查询返回的结果不同。*即当事务T1读取某一数据之后，事务T2对其进行了修改，当事务T1再次读该数据时，得到与前一次不同的值。(读取时允许修改导致不可重复读)*
**丢失修改**：
- 事务T1撤销时，把已经提交的事务T2的更新数据覆盖了；
- 两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。
  
**幻读**：
- 事务T1按一定条件从数据库中都去了某些数据记录之后，事务T2删除了其中部分记录2，当T1再次按相同条件读取数据时，发现某些记录神秘地消失了；
- 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录

**幻读和不可重复度的区别**

- 不可重复读的重点是修改：同样的条件，我们读取过的数据，再次读取出来发现值不一样了
- 幻读的重点在于新增或者删除：同样的条件，第一次和第二次读取出来的记录数不一样


### 事务的特性（ACID）

**原子性**：一个事务必须视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。
**一致性**：数据库总数从一个一致性的状态转换到另一个一致性的状态。
**隔离性**：一个事务所做的修改在最终提交以前，对其他事务是不可见的。
**持久性**：一旦事务提交，则其所做的修改就会永久保存到数据库中。

#### 封锁

封锁就是事务T在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他事务不能更新此数据对象。

**封锁协议**：
- 一级封锁协议：事务T在对数据对象A进行修改之前，必须对其加X锁，直至事务结束才释放。事务结束包括正常结束(COMMIT)和非正常结束(ROLLBACK);
- 二级封锁协议：在一级加锁协议的基础上增加事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁；
- 三级封锁协议：在一级封锁协议的基础上增加事务T在读取数据R之前对其加S锁直至事务结束才释放。

**两段锁协议**
- 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；
- 在释放一个锁之后，事务不再申请和获得任何其他封锁。

**死锁的情况**
- 一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。
- 用户A查询一条纪录，然后修改该条纪录；这时用户B修改该条纪录，这时用户A的事务里锁的性质由查询的共享锁企图上升到独占锁，而用户B里的独占锁由于A 有共享锁存在所以必须等A释放掉共享锁，而A由于B的独占锁而无法上升的独占锁也就不可能释放共享锁，于是出现了死锁。这种死锁比较隐蔽，但在稍大点的项 目中经常发生。如在某项目中，页面上的按钮点击后，没有使按钮立刻失效，使得用户会多次快速点击同一按钮，这样同一段代码对数据库同一条记录进行多次操 作，很容易就出现这种死锁的情况。
- 如果在事务中执行了一条不满足条件的update语句，则执行全表扫描，把行级锁上升为表级锁，多个这样的事务执行后，就很容易产生死锁和阻塞。类似的情 况还有当表中的数据量非常庞大而索引建的过少或不合适的时候，使得经常发生全表扫描，最终应用系统会越来越慢，最终发生阻塞或死锁。